/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * HashAnalysisPanel.java
 *
 * Created on Oct 5, 2011, 11:22:57 AM
 */
package edu.coeia.filesystem;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import edu.coeia.cases.Case;
import edu.coeia.gutil.JTableUtil;
import edu.coeia.hashanalysis.HashCategory;
import edu.coeia.hashanalysis.HashItem;
import edu.coeia.hashanalysis.HashLibraryManager;
import edu.coeia.indexing.IndexingConstant;
import edu.coeia.main.CaseFrame;
import edu.coeia.searching.LuceneSearcher;
import edu.coeia.util.FilesPath;

import java.io.File;


import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import java.util.Map;
import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;


import org.apache.lucene.index.IndexReader ;
import org.apache.lucene.store.Directory ;
import org.apache.lucene.store.FSDirectory;
import org.apache.lucene.document.Document ;
import org.apache.lucene.document.Field;

/**
 *
 * @author wajdyessam
 */
public class HashAnalysisPanel extends javax.swing.JPanel {

    private HashLibraryManager hashLibraryManager ;
    private List<HashCategory> hashCategories ;
    private List<MatchingResult> matchedResult; 
    
    private CaseFrame caseFrame ;
    private Case aCase ;
    private LuceneSearcher luceneSearcher ;
    private Multimap<String, Document> maps = ArrayListMultimap.create();
    
    /** Creates new form HashAnalysisPanel */
    public HashAnalysisPanel(final JPanel parentPanel) {
        initComponents();
        
        this.caseFrame = ((FileSystemPanel)parentPanel).getCaseFrame();
        this.aCase =  ((FileSystemPanel) parentPanel).getCase();
        
        this.hashLibraryManager = new HashLibraryManager();
        this.hashCategories = new ArrayList<HashCategory>();
        this.matchedResult = new ArrayList<MatchingResult>();
        
        this.initializeHashSetList();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTabbedPane1 = new javax.swing.JTabbedPane();
        hashLibraryDuplicationPanel = new javax.swing.JPanel();
        hashSetPanel = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        hashSetJList = new javax.swing.JList();
        hashAnalysisButton = new javax.swing.JButton();
        resultPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        analysisResultTable = new javax.swing.JTable();
        matchedFilesPanel = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        matchedTable = new javax.swing.JTable();
        caseDuplicationPanel = new javax.swing.JPanel();
        resultPanel1 = new javax.swing.JPanel();
        jScrollPane5 = new javax.swing.JScrollPane();
        caseDuplicationTable = new javax.swing.JTable();
        findDuplicationButton = new javax.swing.JButton();
        matchedFilesPanel1 = new javax.swing.JPanel();
        jScrollPane6 = new javax.swing.JScrollPane();
        caseDuplicationResultTable = new javax.swing.JTable();

        hashLibraryDuplicationPanel.setLayout(new java.awt.BorderLayout());

        hashSetPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Hash Library"));

        jScrollPane2.setViewportView(hashSetJList);

        hashAnalysisButton.setText("Hash Analysis");
        hashAnalysisButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                hashAnalysisButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout hashSetPanelLayout = new javax.swing.GroupLayout(hashSetPanel);
        hashSetPanel.setLayout(hashSetPanelLayout);
        hashSetPanelLayout.setHorizontalGroup(
            hashSetPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(hashAnalysisButton, javax.swing.GroupLayout.DEFAULT_SIZE, 129, Short.MAX_VALUE)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 129, Short.MAX_VALUE)
        );
        hashSetPanelLayout.setVerticalGroup(
            hashSetPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, hashSetPanelLayout.createSequentialGroup()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(hashAnalysisButton))
        );

        hashLibraryDuplicationPanel.add(hashSetPanel, java.awt.BorderLayout.WEST);

        resultPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Anlaysis Result"));

        analysisResultTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "File Name", "File path", "Hash Set", "Case Name", "Case Path", "Hash Value", "Investigator Name", "Date"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        analysisResultTable.setFillsViewportHeight(true);
        analysisResultTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                analysisResultTableMouseClicked(evt);
            }
        });
        jScrollPane1.setViewportView(analysisResultTable);

        javax.swing.GroupLayout resultPanelLayout = new javax.swing.GroupLayout(resultPanel);
        resultPanel.setLayout(resultPanelLayout);
        resultPanelLayout.setHorizontalGroup(
            resultPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(resultPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 482, Short.MAX_VALUE)
                .addContainerGap())
        );
        resultPanelLayout.setVerticalGroup(
            resultPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 155, Short.MAX_VALUE)
        );

        hashLibraryDuplicationPanel.add(resultPanel, java.awt.BorderLayout.CENTER);

        matchedFilesPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Matched Files in Case"));

        matchedTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "File Name", "File Path", "Date", "Hash Value"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.Object.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        matchedTable.setFillsViewportHeight(true);
        jScrollPane3.setViewportView(matchedTable);

        javax.swing.GroupLayout matchedFilesPanelLayout = new javax.swing.GroupLayout(matchedFilesPanel);
        matchedFilesPanel.setLayout(matchedFilesPanelLayout);
        matchedFilesPanelLayout.setHorizontalGroup(
            matchedFilesPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(matchedFilesPanelLayout.createSequentialGroup()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 637, Short.MAX_VALUE)
                .addContainerGap())
        );
        matchedFilesPanelLayout.setVerticalGroup(
            matchedFilesPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 194, Short.MAX_VALUE)
        );

        hashLibraryDuplicationPanel.add(matchedFilesPanel, java.awt.BorderLayout.PAGE_END);

        jTabbedPane1.addTab("Files Duplication within Hash Library", hashLibraryDuplicationPanel);

        caseDuplicationPanel.setLayout(new java.awt.BorderLayout());

        resultPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Anlaysis Result"));

        caseDuplicationTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Hash Value", "Number of Duplication"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        caseDuplicationTable.setFillsViewportHeight(true);
        caseDuplicationTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                caseDuplicationTableMouseClicked(evt);
            }
        });
        jScrollPane5.setViewportView(caseDuplicationTable);

        findDuplicationButton.setText("Find Duplication");
        findDuplicationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findDuplicationButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout resultPanel1Layout = new javax.swing.GroupLayout(resultPanel1);
        resultPanel1.setLayout(resultPanel1Layout);
        resultPanel1Layout.setHorizontalGroup(
            resultPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, resultPanel1Layout.createSequentialGroup()
                .addComponent(jScrollPane5, javax.swing.GroupLayout.DEFAULT_SIZE, 534, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(findDuplicationButton))
        );
        resultPanel1Layout.setVerticalGroup(
            resultPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(resultPanel1Layout.createSequentialGroup()
                .addComponent(findDuplicationButton)
                .addContainerGap(132, Short.MAX_VALUE))
            .addComponent(jScrollPane5, javax.swing.GroupLayout.DEFAULT_SIZE, 155, Short.MAX_VALUE)
        );

        caseDuplicationPanel.add(resultPanel1, java.awt.BorderLayout.CENTER);

        matchedFilesPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Matched Files in Case"));

        caseDuplicationResultTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "File Name", "File Path", "Date", "Hash Value"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.Object.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        caseDuplicationResultTable.setFillsViewportHeight(true);
        jScrollPane6.setViewportView(caseDuplicationResultTable);

        javax.swing.GroupLayout matchedFilesPanel1Layout = new javax.swing.GroupLayout(matchedFilesPanel1);
        matchedFilesPanel1.setLayout(matchedFilesPanel1Layout);
        matchedFilesPanel1Layout.setHorizontalGroup(
            matchedFilesPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(matchedFilesPanel1Layout.createSequentialGroup()
                .addComponent(jScrollPane6, javax.swing.GroupLayout.DEFAULT_SIZE, 637, Short.MAX_VALUE)
                .addContainerGap())
        );
        matchedFilesPanel1Layout.setVerticalGroup(
            matchedFilesPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane6, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 194, Short.MAX_VALUE)
        );

        caseDuplicationPanel.add(matchedFilesPanel1, java.awt.BorderLayout.PAGE_END);

        jTabbedPane1.addTab("Files Duplication in the same Case", caseDuplicationPanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 668, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jTabbedPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 437, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void hashAnalysisButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_hashAnalysisButtonActionPerformed
        resetGUIComponent();
        
        Object[] values = this.hashSetJList.getSelectedValues();
        for(Object obj: values) {
            String value = String.valueOf(obj);
            this.startHashAnalysis(value);
        }
        
        if ( this.matchedResult.isEmpty() ) {
            JOptionPane.showMessageDialog(null, "There is no duplication with selected hash set(s)",
                    "cannot find any matched files in this case",
                    JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_hashAnalysisButtonActionPerformed

    private void analysisResultTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_analysisResultTableMouseClicked
        
        JTableUtil.removeAllRows(this.matchedTable);
        
        int row = this.analysisResultTable.getSelectedRow();
        if ( row < 0 ) return ;
        
        MatchingResult result = this.matchedResult.get(row);
        for(Document document: result.matchingDocuments) {
            if ( IndexingConstant.isFileDocument(document) ) {
                String fileName = document.get(IndexingConstant.FILE_TITLE);
                String filePath = document.get(IndexingConstant.FILE_NAME);
                String date = document.get(IndexingConstant.FILE_DATE);
                String hash = document.get(IndexingConstant.DOCUMENT_HASH);
                
                Object[] data = {fileName, filePath, date, hash};
                JTableUtil.addRowToJTable(this.matchedTable, data);
            }
        }
    }//GEN-LAST:event_analysisResultTableMouseClicked

    private void findDuplicationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findDuplicationButtonActionPerformed
        this.resetCaseDuplicationElements();
        this.findDuplicationInCurrentCase();
    }//GEN-LAST:event_findDuplicationButtonActionPerformed

    private void caseDuplicationTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_caseDuplicationTableMouseClicked
        int row = this.caseDuplicationTable.getSelectedRow();
        if ( row < 0 ) return ;
        
        JTableUtil.removeAllRows(this.caseDuplicationResultTable);
        
        String key = String.valueOf(this.caseDuplicationTable.getValueAt(row, 0));
        Collection<Document> documents = this.maps.get(key);
        for(Document document: documents) {
            if ( IndexingConstant.isFileDocument(document) ) {
                String fileName = document.get(IndexingConstant.FILE_TITLE);
                String filePath = document.get(IndexingConstant.FILE_NAME);
                String date = document.get(IndexingConstant.FILE_DATE);
                String hash = document.get(IndexingConstant.DOCUMENT_HASH);
                
                Object[] data = {fileName, filePath, date, hash};
                JTableUtil.addRowToJTable(this.caseDuplicationResultTable, data);
            }
        }
    }//GEN-LAST:event_caseDuplicationTableMouseClicked

    private void findDuplicationInCurrentCase() {
        try {
            this.findDuplication();
        }
        catch(Exception e){
            e.printStackTrace();
        }
    }
    
    public void findDuplication() throws Exception {
        String indexDir = this.aCase.getCaseLocation() + "\\" + FilesPath.INDEX_PATH;
        Directory dir = FSDirectory.open(new File(indexDir));
        IndexReader indexReader = IndexReader.open(dir);
        
        for (int i=0; i<indexReader.maxDoc(); i++) {
            Document document = indexReader.document(i);
            if ( document != null ) {
                Field field = document.getField(IndexingConstant.DOCUMENT_HASH);
                if ( field != null && field.stringValue() != null) {
                   String documentHash = field.stringValue();
                   this.maps.put(documentHash, document);
                }
            }
        }
        indexReader.close();
        
        Map<String, Collection<Document>> m = this.maps.asMap();
        
        boolean isFoundDuplication = false; 
        
        for(Map.Entry<String, Collection<Document>> mapEntry: m.entrySet()){
            String key = mapEntry.getKey();
            Collection<Document> documents = mapEntry.getValue();
            
            if ( documents.size() > 1 ) { // find duplication  
                isFoundDuplication = true;
                Object[] data = {key, documents.size()};
                JTableUtil.addRowToJTable(this.caseDuplicationTable, data);
            }
        }
        
        if ( !isFoundDuplication ) {
            JOptionPane.showMessageDialog(null, "There is no duplication in this case");
        }
    }
        
    private void initializeHashSetList() {
        String hashSetLocation = FilesPath.HASH_LIBRARY_PATH;
        List<File> hashSetsLocation = this.hashLibraryManager.getHashSets(hashSetLocation);
        
        DefaultListModel model = new DefaultListModel();
        for(File file: hashSetsLocation) {
            HashCategory hashCategory = this.hashLibraryManager.getHashCategory(file);
            this.hashCategories.add(hashCategory);
            model.addElement(hashCategory.getName());
        }
        
        this.hashSetJList.setModel(model);
    }
        
    private void startHashAnalysis(final String hashSetName) {
        HashCategory hashCategory = this.getHashCategory(hashSetName);
        
        for(HashItem item: hashCategory.getItems()) {
            String hashValue = item.getHashValue();
            List<Document> documents = searchFor(hashValue);
            
            if ( !documents.isEmpty() ) {
                //System.out.println("found matching for hash: " + hashValue);
                
                // add data
                Object[] data = {
                    item.getFileName(), item.getFilePath(), 
                    hashSetName, item.getCaseName(), item.getCasePath(), 
                    item.getHashValue(), item.getInvestigatorName(), item.getTime()
                };
                
                JTableUtil.addRowToJTable(this.analysisResultTable, data);
                
                // build result object
                // so we can extract the duplicated files in case
                MatchingResult result = new MatchingResult();
                result.matchingDocuments.addAll(documents);
                result.hashItem = item;
                result.hashCategory = hashCategory; 
                
                // add to result list
                this.matchedResult.add(result);
            }
            else {
                //System.out.println("cannot find matchign for: " + hashValue);
            }
        }
    }
    
    private class MatchingResult {
        HashCategory hashCategory;
        HashItem hashItem;
        List<Document> matchingDocuments = new ArrayList<Document>();
    }
    
    private List<Document> searchFor(final String hashValue) {
        List<Document> documents = new ArrayList<Document>();
        
        try {
            this.luceneSearcher = new LuceneSearcher(new File(this.aCase.getCaseLocation() + "\\" + FilesPath.INDEX_PATH));
            
            int hits = this.luceneSearcher.searchForHash(hashValue);
            
            for(int i=0; i<hits; i++) {
                Document document = this.luceneSearcher.getDocHits(i);
                documents.add(document);
            }
            
        }
        catch(Exception e) {
            e.printStackTrace();
        }
        finally {
            this.closeLuceneSearch();
        }
        
        return documents;
    }
    
    private HashCategory getHashCategory(final String hashSetName) {
        HashCategory hashCategory = null;
        
        for(HashCategory tmp: this.hashCategories ) {
            if ( tmp.getName().equals(hashSetName) ) {
                hashCategory = tmp;
                break;
            }
        }
        
        return hashCategory;
    }
    
    private void closeLuceneSearch() {
        try {
            if ( this.luceneSearcher != null )
                this.luceneSearcher.closeSearcher();
        }
        catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    
    private void resetGUIComponent() {
        JTableUtil.removeAllRows(this.analysisResultTable);
        JTableUtil.removeAllRows(this.matchedTable);
        this.matchedResult.clear();
    }
    
    private void resetCaseDuplicationElements() {
        this.maps.clear();
        JTableUtil.removeAllRows(this.caseDuplicationResultTable);
        JTableUtil.removeAllRows(this.caseDuplicationTable);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable analysisResultTable;
    private javax.swing.JPanel caseDuplicationPanel;
    private javax.swing.JTable caseDuplicationResultTable;
    private javax.swing.JTable caseDuplicationTable;
    private javax.swing.JButton findDuplicationButton;
    private javax.swing.JButton hashAnalysisButton;
    private javax.swing.JPanel hashLibraryDuplicationPanel;
    private javax.swing.JList hashSetJList;
    private javax.swing.JPanel hashSetPanel;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JPanel matchedFilesPanel;
    private javax.swing.JPanel matchedFilesPanel1;
    private javax.swing.JTable matchedTable;
    private javax.swing.JPanel resultPanel;
    private javax.swing.JPanel resultPanel1;
    // End of variables declaration//GEN-END:variables
}
